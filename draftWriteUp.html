<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>README_04.md</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
body{
    margin: 0 auto;
    font-family: "Minion Pro", Georgia, serif;
    color: #444444;
    line-height: 1;
    max-width: 960px;
    padding: 5px;
}
h1, h2, h3, h4 {
    color: #111111;
    font-weight: normal;
}
h1, h2, h3, h4, h5, p {
    margin-bottom: 16px;
    padding: 0;
}
h1 {
    font-size: 28px;
}
h2 {
    font-size: 1.4em;
    margin: 1.714em 0px;
}
h3 {
    font-size: 1.1em;
    margin: 2.195em 0px;
}
h4 {
    font-size: 18px;
}
h5 {
    font-size: 16px;
}
a {
    color: #0099ff;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
}
a:hover {
    text-decoration: none;
    color: #ff6600;
}
a:visited {
    color: purple;
}
ul, ol {
    padding: 0;
    margin: 0;
}
li {
    line-height: 24px;
    margin-left: 44px;
}
li ul, li ul {
    margin-left: 24px;
}
p, ul, ol {
    font-size: 18px;
    font-weight: 400;
    line-height: 22px;
    max-width: 825px;
    margin: 1.333em 0px
}
pre {
    padding: 0px 24px;
    max-width: 800px;
    white-space: pre-wrap;
}
code {
    font-family: Consolas, Monaco, Andale Mono, monospace;
    line-height: 1.5;
    font-size: 13px;
}
aside {
    display: block;
    float: right;
    width: 390px;
}
blockquote {
    border-left:.5em solid #eee;
    padding: 0 2em;
    margin-left:0;
    max-width: 476px;
}
blockquote  cite {
    font-size:14px;
    line-height:20px;
    color:#bfbfbf;
}
blockquote cite:before {
    content: '\2014 \00A0';
}

blockquote p {  
    color: #666;
    max-width: 460px;
}
hr {
    width: 540px;
    text-align: left;
    margin: 0 auto 0 0;
    color: #999;
}

button,
input,
select,
textarea {
  font-size: 100%;
  margin: 0;
  vertical-align: baseline;
  *vertical-align: middle;
}
button, input {
  line-height: normal;
  *overflow: visible;
}
button::-moz-focus-inner, input::-moz-focus-inner {
  border: 0;
  padding: 0;
}
button,
input[type="button"],
input[type="reset"],
input[type="submit"] {
  cursor: pointer;
  -webkit-appearance: button;
}
input[type=checkbox], input[type=radio] {
  cursor: pointer;
}
/* override default chrome & firefox settings */
input:not([type="image"]), textarea {
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

input[type="search"] {
  -webkit-appearance: textfield;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
label,
input,
select,
textarea {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 13px;
  font-weight: normal;
  line-height: normal;
  margin-bottom: 18px;
}
input[type=checkbox], input[type=radio] {
  cursor: pointer;
  margin-bottom: 0;
}
input[type=text],
input[type=password],
textarea,
select {
  display: inline-block;
  width: 210px;
  padding: 4px;
  font-size: 13px;
  font-weight: normal;
  line-height: 18px;
  height: 18px;
  color: #808080;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}
select, input[type=file] {
  height: 27px;
  line-height: 27px;
}
textarea {
  height: auto;
}

/* grey out placeholders */
:-moz-placeholder {
  color: #bfbfbf;
}
::-webkit-input-placeholder {
  color: #bfbfbf;
}

input[type=text],
input[type=password],
select,
textarea {
  -webkit-transition: border linear 0.2s, box-shadow linear 0.2s;
  -moz-transition: border linear 0.2s, box-shadow linear 0.2s;
  transition: border linear 0.2s, box-shadow linear 0.2s;
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}
input[type=text]:focus, input[type=password]:focus, textarea:focus {
  outline: none;
  border-color: rgba(82, 168, 236, 0.8);
  -webkit-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
  -moz-box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
  box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 8px rgba(82, 168, 236, 0.6);
}

/* buttons */
button {
  display: inline-block;
  padding: 4px 14px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 13px;
  line-height: 18px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);
  background-color: #0064cd;
  background-repeat: repeat-x;
  background-image: -khtml-gradient(linear, left top, left bottom, from(#049cdb), to(#0064cd));
  background-image: -moz-linear-gradient(top, #049cdb, #0064cd);
  background-image: -ms-linear-gradient(top, #049cdb, #0064cd);
  background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #049cdb), color-stop(100%, #0064cd));
  background-image: -webkit-linear-gradient(top, #049cdb, #0064cd);
  background-image: -o-linear-gradient(top, #049cdb, #0064cd);
  background-image: linear-gradient(top, #049cdb, #0064cd);
  color: #fff;
  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
  border: 1px solid #004b9a;
  border-bottom-color: #003f81;
  -webkit-transition: 0.1s linear all;
  -moz-transition: 0.1s linear all;
  transition: 0.1s linear all;
  border-color: #0064cd #0064cd #003f81;
  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);
}
button:hover {
  color: #fff;
  background-position: 0 -15px;
  text-decoration: none;
}
button:active {
  -webkit-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
  -moz-box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
  box-shadow: inset 0 3px 7px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);
}
button::-moz-focus-inner {
  padding: 0;
  border: 0;
}

</style>
</head>
<body>
<h1><strong>e-Party: A IndexedDB Tutorial</strong></h1>

<p><strong><em>Storage. Lots of it. On the client-side! IndexedDB is not your typical DOM Storage.  With the ability to store a large amount of data on the client-side, IndexedDB will usher a whole new method on web application architecture.  IndexedDB is an experimental technology with awesome powers. In this tutorial we will show how to implement the asynchronous IndexedDB API by applying it to an e-Party Invitation List manager.</em></strong></p>

<h2><strong>IndexedDB</strong></h2>

<p>IndexedDB is not a relational database.  IndexedDB stores and retrieves objects that are indexed by a key.  Instead of rows, columns and tables IndexedDB has documents, fields and collections.  IndexedDB builds on the transactional database model, which states that every operation in IndexedDB happens within an  atomic framework of a transaction.  IndexedDB is not a substitute for DOM Storage but rather a solution for storing large amounts of structured data on the client-side.  For more information on IndexedDB checkout <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/Basic_Concepts_Behind_IndexedDB">Basic Concepts</a>.  </p>

<p>The focus of this tutorial will be on syntax implementation of IndexedDB. IndexedDB can be accessed via Firefox >= 16, Chrome >= 23 , and IE 10 (<a href="http://caniuse.com/#search=indexedDB">caniuse</a>). This tutorial was tested in Firefox >= 16, Chrome >= 24 and IE 10. If you are using IE you need a server to get IndexedDB up and running since only <code>http</code> and <code>https</code> schemes are allowed access to IndexedDB</p>

<h2><strong>e-Party Application</strong></h2>

<p>In this small tutorial we will be build and use a database named "Invitation List".  The application will allow a user to create and delete party events and keep track of guests that have been invited to the events.  The database will store two types of object stores: <em>Events</em> and <em>Guests</em>.  Documents belonging to the <em>Events</em> object store hold the fields event and host name, the location and time of the event.  A single document in the <em>Guests</em> object store contains a name, email and the event to which the guest was invited to attend.  Checkout the <a href="file:///C:/Users/maoMao/Documents/webDev/JSPro/IndexedDB_Draft.html">demo!!!</a></p>

<h4><strong>How it works</strong></h4>

<p>A party planner wants to keep track of all scheduled events and invited guests.  The <em>e-Party</em> application uniquely identifies events by their name and time, and guests by their email address.  Any guest can be invited to multiple events but they cannot be added twice to the same event.  And guests can only be invited to events that are identifiable in the <em>Events</em> object store.  Finally, if an event or guest is removed from the DOM they are also deleted from the database.</p>

<p>Below is an example of the documents:</p>

<script src="https://gist.github.com/0ac2cf1be69b10d161e2.js"></script>

<h2><strong>Using IndexedDB</strong></h2>

<p>The application tutorial shows how to use IndexedDB to connect to a database and perform read/write operations.  Many of the database operations covered follow a very common pattern: </p>

<ol>
<li>Open a transaction to an object store</li>
<li>Make a request to do some database operations</li>
<li>Do something with the results</li>
</ol>

<p>But before we can engage in any database transaction we must first connect to a database.</p>

<h4><strong>Open a Database</strong></h4>

<p>Below is the code that opens the e-Party <em>Invitation List</em> database:</p>

<script src="https://gist.github.com/b6a6f4ec92c68a505084.js"></script>

<p>To open the database a <em>request</em> is made to the <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBFactory#open">open()</a> method via the <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBFactory">IDBFactory API</a>.  The method is passed two arguments: the database name and the version number.  If the database does not exist it is created.  The version number tracks the state of the database and since this is the first time accessing the database a verion value of <code>1</code> is given.  Note that only one version of the database can exist at any given time.  </p>

<p>The <em>request</em> returns an <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBOpenDBRequest">IDBOpenDBRequest</a> object that provides the interface to access the database.  The <em>IDBOpenDBRequest</em> API inherits from the <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBRequest">IDBRequest API</a> which provides specific event handler attributes that respond to the asynchronous operation. </p>

<h4><strong>Create an Object Store</strong></h4>

<p>The <code>upgradeneeded</code> is triggered when the database is first created and when there is a version change.  The result returns a <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase">IDBDatabase</a> object, which we need to connect to throughout the application.  With the <code>createObjectStore()</code> method of the <em>IDBDatabase</em> we setup our two application object stores. </p>

<p>The <code>createObjectStore()</code> takes two arguments: the name of the object store to create and an optional parameter object.  The parameter object takes a <code>key path</code> and <code>key generator</code> that gives you control on how you want the inserted data values to be uniquely identified.  There are <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/Using_IndexedDB#Structuring_the_database">four possible</a> ways to structure the object stores through the parameter object.  The <code>key path</code> is the equivalent of a <em>primary key</em> in a relational DB. The <code>key generator</code> value <code>autoIncrement: true</code> tells IndexedDB to increment the keys automatically as the data values are inserted into the object store.</p>

<p>With the <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore">IDBObjectStore</a> object we can apply indexes to the object store fields using the <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore#createIndex%28%29"><code>createIndex()</code></a> method.  Besides providing for a quick lookup and the ability to query without using a key the method also allows for data value constraints.  The three arguments given above state the <em>name</em> and <em>key path</em> of the index with an object with the boolean property <code>unique</code>.  Although the <code>createIndex()</code> method is optional its a good idea to use it to outline your schema.</p>

<p>After creating the object stores the <code>request.onsuccess</code> handler is triggered. Now that we have the database up and running we are ready to interact with the database.</p>

<ul>
<li><strong>Make a request to do some database operations</strong></li>
<li><strong>Wait for the operation to complete</strong></li>
<li><strong>Do something with the results</strong></li>
</ul>

<p>At this point the user will interact with the application scheduling events and inviting guests.  Before adding the event into the database we first process the event and if everything checks-out we add it to the database.  Below is the first step.</p>

<p><strong>getEvent:</strong>  </p>

<script src="https://gist.github.com/3b74c0699e9de57f5848.js"></script>

<p>The only way to access a database for reading and writing is through the <em>IDBDatabase</em> <code>transaction()</code> method.  All transaction are atomic so write operations are either committed or not.  Once insided a transaction access to a specified object store is given.  It is within this <em>scope</em> that reading and writing is conducted.  To open a <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBTransaction">transaction</a> specifiy the scope and mode.  There are only three modes that allow for any interaction with the database:</p>

<ol>
<li>readonly ---- read access to the db</li>
<li>readwrite ---- read and write access to the db</li>
<li>versionchange ---- create/modify the object store</li>
</ol>

<p>In the <code>getEvent()</code> we are only accessing the <code>Events</code> object store and applying a mode of 'readonly'.  If no mode is specified the default is 'readonly'.  Once within the <code>transaction</code> the <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore">objectStore()</a> method is called to request the object store to access. The  method returns the <code>Events</code> object store establishing a reference for the coming query.</p>

<p>A typical query calls the <code>get()</code> method on the object store but that assumes we know the <code>key path</code> of the data value.  From the <code>onupgradeneeded</code> above we let IndexedDB handle assigning key values so we do not know the events <code>key path</code> before hand.  What we do instead is query the event's name by opening the named index <code>event</code> on the object store.  This allows us to directly query the name of the event.</p>

<p>Before directly querying for the event name the code above has a series of checks that can be helpful at targeting specific queries in IndexedDB.  The first check is the <code>count()</code> method on the indexed object store <code>reqInx</code>.  The result is a number signifying how many records have the event name.  If the number is zero we know immediately no such record exists and can proceed to adding the record to the database.  On the other hand, if a number greater than zero is returned we proceed to the next step which is getting the record and performing the second check.  </p>

<p>We know that a certain number of records exist with the given event name.  We extract those records by using the <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore#openCursor%28%29"><code>openCursor()</code></a> method on <code>reqInx</code>, which creates a cursor over the records.  Regardless if a record exists or not the <code>onsuccess</code> handler is triggered.  Checking if the cursor exists gives us an added option to control what happens next.  If a cursor exists we get the cursor value and check the record against the user input.  If the check passes we know that the user added event already exists in the database and we return that record.  If the check fails we call <code>cursor.continue()</code> to iterate the cursor.  We continue in this fashion until we find a cursor value that matches or until the cursor runs out of records to check, in which returns <code>null</code>.  In the event <code>null</code> we return <code>false</code> and proceed to add the event into the database.</p>

<script src="https://gist.github.com/76c5846bd2113970d89d.js"></script>

<p>To add the event to the database we setup a transaction of scope <code>Events</code> and a mode of 'readwrite'.  We target the <code>Events</code> object store and then call the <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBObjectStore#add%28%29"><code>add()</code></a> method.  The <code>onsuccess</code> event is triggered and the key used to store the event is returned.</p>

<h3><strong>Working with Errors</strong></h3>

<p>Now that we know how reading and writing looks like in IndexedDB let's take a step back and talk about <em>errors</em>.  Every asynchronous operation returns an <a href="https://developer.mozilla.org/en-US/docs/IndexedDB/IDBRequest">IDBRequest</a> instance that returns a <em>result</em> and an <em>error</em>.  Depending if the <em>request</em> object is successful determines if the handler <code>onsuccess</code> or <code>onerror</code> is triggered.  Looking back at our code for every <em>request</em> made there is a pair of <code>onsuccess</code> and <code>onerror</code> handlers.  </p>

<p>Note that the 'get()' and 'delete()' objectStore methods trigger the <code>onsuccess</code> handler regardless if a record exists to retrieve or to delete.  By using the <code>cursor</code> method described above you can distinguish between a record existing or not.  If you want to check if a key exists before deleting the record you can check that it exists and then delete.  The latter is demonstrated later in this tutorial.</p>

<h3><strong>Adding Guests</strong></h3>

<p>At this point the user has successfully added various events to the e-Party Invitation List and now wishes to add invited guests to specific events.  The user selects an event and a time to add a guest to and then inputs a guest name and a unique email.  Recieving the user input the next step is to verify that the event and time selected coincide.  Then to check if the email is unique and that the guest is not already on the list.</p>

<p><strong>processGuest</strong></p>

<script src="https://gist.github.com/f1bffe23b8a3823e9d4b.js"></script>

<p>Checking for the event has been discussed above.  Suffice to say that if a <code>cursor.value</code> is not returned then the alert is triggered and we start over.</p>

<p><strong>getGuest</strong></p>

<script src="https://gist.github.com/a765d52cea1434d62d2a.js"></script>

<p>The <code>getGuest()</code> is exactly the same as the <code>getEvent()</code> function.  We use <code>count()</code> and <code>openCursor()</code> to check if the email and name coinside.  If they do coinside we proceed to check that the guest is not already in the list by checking the <code>EID</code>'s.  If at any time 'true' is returned an alert is triggered letting the user know that the guest email is taken or the guest is already on the list.  If 'false' is returned we proceed to adding the guest into the database.</p>

<p><strong>addGuestToDB</strong></p>

<script src="https://gist.github.com/3abd8d6ad90697c43a23.js"></script>

<p>No surprise that the function looks exactly the same as the <code>addEventToDB()</code> except here the transaction is over the <code>Guests</code> scope.</p>

<h3><strong>Deleting Events and Guests</strong></h3>

<p>Our application has two ways to delete guests from the database.  The user can individually select which guest to 'uninvite' from an event or the user can completely remove an event which also removes associated guests.  Both cases follow the same pattern in deleteing data from the database.  We focus here on the removal of the event and associated guests.</p>

<script src="https://gist.github.com/b29021e6ea748472b17e.js"></script>

<p>The <code>delete()</code> method of the <em>objectStore</em> accepts as input the key identifying the record to delete.  When the user <em>clicks</em> to remove an event we retrieve the event key by calling the <code>getEvent()</code> function.  Opening a transaction with mode "readwrite" and calling 'delete()' on the objectStore we delete the event from the database.  <code>onsuccess</code> we pass the event key <code>EID</code> to identify which guests belong to the event and delete them from the database.</p>

<script src="https://gist.github.com/e106a0aac36e4f7ef0b7.js"></script>

<p>Scoping the transaction to the <code>Guests</code> objectStore and calling <code>index()</code> on the key <code>EID</code> we open a cursor that iterates over all guests that belong to the event.  For every guest returned by the cursor the <code>delete()</code> method is used on the guest key <code>GID</code>.  The <code>onsuccess</code> is triggered for every successful deletion and if there are any problems the <code>onerror</code> handler will notify.</p>

<h2><strong>Conclusion</strong></h2>

<p>IndexedDB is an alternative to DOMStorage for applications that have large storage requirements for structured data.  The syntax for working with IndexedDB is straight-forward and creating general functions that <code>get()</code>, <code>add()</code> and <code>delete()</code> make IndexedDB get out the way and focus on developing your application without worrying about storage space.</p>

</body>
</html>
